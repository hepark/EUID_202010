[← BACK](./README.md)

# 이벤트 핸들링

React 요소에서 이벤트를 핸들링 하는 방식

- DOM 요소의 이벤트를 핸들링 방식과 유사하다.
- 이벤트 속성 이름은 camelCase 형식으로 작성한다. (예: onClick)
- 속성 값에 문자열 대신 JSX 형식으로 메서드를 연결한다. (예: onClick={ onClickHandler })
- 브라우저 기본 동작을 중단하려면 반드시 e.preventDefault()를 사용해야 한다.

## DOM 요소 이벤트 핸들링

<!-- HTML 요소의 표준 이벤트 속성 값으로 함수를 연결합니다. -->

## React 요소 이벤트 핸들링

<!-- JSX에선 camelCase 이벤트 속성 이름에 {} 안에 함수 이름을 연결합니다. -->

## 브라우저 기본 동작 차단

<!-- 브라우저 기본 동작을 차단하려면? 이벤트 속성에 연결된 이벤트 리스너(함수)에 전달된 이벤트 객체의 preventDefault() 메서드를 사용합니다.

```javascript
```
-->

## 이벤트 핸들러와 this

<!-- 앞서 작성한 PreventBrowserDefaultAction 함수형 컴포넌트를 클래스 컴포넌트로 사용할 경우, 메서드의 this 참조(ref.)에 대해 주의가 필요합니다. 어떤 문제가 발생할 수 있는지 알아 보겠습니다. 클래스 컴포넌트로 변경한 후 Google 링크를 클릭하면 브라우저 기본 동작은 차단되지만, this 참조가 컴포넌트 인스턴스가 아닌 undefined를 출력합니다. -->

<!-- ```javascript
``` -->

## 클래스 컴포넌트 this 참조 변경

<!-- 클래스 컴포넌트의 JSX 이벤트 핸들링 구문에서 이벤트 속성에 연결된 메서드의 this 참조가 undefined일 경우 제대로 작동하지 않는 문제가 발생합니다. 이 문제를 해결하기 위한 여러가지 방법을 하나 하나 살펴봅시다. -->

### 1. this 참조 변경

<!-- JavaScript 함수는 bind() 메서드를 사용해 this 참조를 임의로 변경할 수 있습니다. 이 방법을 사용하여 메서드의 this 참조가 컴포넌트 인스턴스를 가리키도록 변경합니다. 예시를 살펴봅시다. -->

### 2. 화살표 함수 활용

<!-- 컴포넌트 메서드를 래핑하는 익명 함수(화살표 함수)를 사용하면 이벤트 발생 시 this 참조를 컴포넌트 인스턴스로 설정할 수 있습니다. 예시를 살펴봅니다. -->

#### 3. 클래스 필드 구문 활용

<!-- ES 표준에 제안된 문법인 클래스 필드 구문을 사용해 문제를 해결할 수도 있습니다. 객체의 향상된 표기법 대신 화살표 함수 방식으로 메서드를 정의하면 this 참조가 컴포넌트 인스턴스를 가리키게 됩니다. -->

### 이벤트 핸들러 인자 전달

<!-- React 컴포넌트 메서드(이벤트 리스너일 경우)에 특정 인자를 전달하는 방법은 다음의 2가지가 있습니다. -->

### 화살표 함수

<!-- 클래스 컴포넌트의 메서드를 래핑하는 화살표 함수를 이벤트 속성에 연결한 후, 아래와 같이 특정 인자를 전달할 수 있습니다. -->

### Function.prototype.bind

<!-- 클래스 컴포넌트 메서드에 특정 인자를 전달해 실행한 후, JavaScript 함수의 bind() 메서드를 사용해 this 참조를 변경합니다. -->

# 컴포넌트 통신

<!--React 클래스 컴포넌트는 컴포넌트 내에서만 접근 가능한 상태(state)를 가질 수 있어 관리가 용이하지만, 컴포넌트가 중첩되더라도 각 컴포넌트마다 개별적으로 상태를 관리하므로 상태를 공유하는 것이 까다롭습니다.

> 일반적으로 클라이언트 환경의 JavaScript는 스코프 체인에 의해 상위(부모) 영역으로 거슬러 올라가 데이터를 참조하지만, React 프로그래밍에서는 각 컴포넌트의 상태(데이터)가 스코프 체인 되지 않습니다.

보다 효과적으로 상태를 관리하기 위해서 React 프로그래밍에서는 부모(상위) 컴포넌트가 (공유가 필요한) 상태를 관리하고, 자손(하위) 컴포넌트는 부모 컴포넌트와 통신(Communication)하여 상태 공유를 처리합니다.

> React 공식 문서는 해당 내용을 상태 끌어올리기(Lifting State Up)로 기술하고 있습니다. 필자는 '상태 끌어올리기'라는 표현이 선뜻 이해하기 쉽지 않다고 판단하여, 해당 섹션 이름을 '컴포넌트(부모 ➪ 자식) 간 통신'으로 바꿔 기술했습니다.-->

## props ⇌ callback

<!-- 전달 속성(props)를 사용해 부모 컴포넌트는 자식 컴포넌트에 속성을 전달할 수 있습니다. 바꿔 말하면 자식 컴포넌트는 부모 컴포넌트로 부터 속성을 전달 받을 수 있습니다. 컴포넌트의 메서드 또한 속성이므로 props로 전달할 수 있습니다. 예를 들어 부모 컴포넌트의 메서드를 자식 컴포넌트에 전달하면 자식 컴포넌트는 전달 받은 메서드를 실행(callback)해 부모 컴포넌트의 상태를 변경할 수 있습니다. -->

## 부모 ➡︎ 자식 (메서드 전달)

<!-- 자식 컴포넌트에 전달된(1) 부모 컴포넌트 메서드(2)는 자식 컴포넌트에 의해 실행되면 부모 컴포넌트의 상태를 업데이트(3) 합니다.

```javascript
``` -->

## 부모 ⬅︎ 자식 (메서드 실행)

<!-- 자식 컴포넌트는 state를 가질 필요가 없으므로 '함수형'으로 작성합니다. 눈여겨 볼 부분은 부모 컴포넌트가 전달한 속성 props.receivedMethod 유형이 메서드라는 점입니다. 사용자에 의해 이벤트가 발생(버튼 요소 클릭) 하면 전달 받은 부모 컴포넌트의 메서드를 실행해 부모 컴포넌트의 state를 교체합니다.

```javascript
``` -->

## props ⇌ callback 문제

<!-- 불행히도 props, callback을 활용한 컴포넌트 통신 방법은 간단한 시나리오를 벗어나면 현실적이지 않습니다. 애플리케이션은 많은 컴포넌트가 상태를 가지고 있거나, 다른 컴포넌트와 공유(동기화)해 상호 작용 되어야 합니다. 하지만 애플리케이션의 상태를 컴포넌트가 개별적으로 소유하다 보니 관리의 어려움이 생기는 겁니다. 자신의 상태를 하위 컴포넌트에 전송 → 전송 → 전송, 다시 하위 컴포넌트에서 상위 컴포넌트로 콜백 ← 콜백 ← 콜백 하니 복잡하고 어려워집니다. 다시 말해 컴포넌트 간 관계가 복잡해지면 props, callback은 관리가 매우 어려워집니다. -->

## 컨텍스트(Context) 활용

<!-- React는 중첩된 컴포넌트의 데이터 공유 문제를 해결하기 위한 방법으로 컨텍스트(Context)를 제공합니다. Context를 사용하면 컴포넌트 트리로 묶인 컴포넌트 간 데이터 공유가 비교적 수월해집니다. 단, Context는 컴포넌트를 재사용하기 어렵게 만드므로 꼭 필요한 경우만 사용하는 것이 좋습니다. -->

## 상태 관리 시스템의 필요성

<!-- 상태 관리 시스템은 상태 관리의 복잡한 문제를 해결하기 위해 고안되었습니다. 상태를 각 컴포넌트가 소유하는데서 기인된 문제 해결 방안으로 모든 상태를 하나의 저장소(Store)에서 관리하도록 만드는 것입니다. 이러한 접근법은 여러가지 문제를 해결할 수 있습니다. 복잡한 컴포넌트 계층을 위/아래로 탐색하지 않고도 상태를 공유할 수 있기 때문입니다. 대표적인 상태 관리 라이브러리로 Redux, Mobx, Vuex 등이 있습니다. -->
